---
title: "Using Functions in Series"
subtitle: "RAdelaide 2025"
author: "Dr Stevie Pederson"
institute: |
  | Black Ochre Data Labs
  | Telethon Kids Institute
date: "2025-07-08"
date-format: long
bibliography: bibliography.bib
title-slide-attributes:
    data-background-color: "#3d3d40"
    data-background-image: assets/bodl_logo_white_background.jpg
    data-background-opacity: "0.3"
    data-background-size: "90%"
editor: source
format:
  revealjs:
    theme: [bodl.scss]
    code-line-numbers: false
    code-tools: true
    logo: assets/bodl_logo_white_background.jpg
    height: 720
    width: 1280
    sansfont: Times New Roman
    slide-number: c
    show-slide-number: all
  html:
    css: [bodl.scss, extra.css]
    output-file: piping.html
    embed-resources: true
    toc: true
    toc-depth: 1
include-after: |
  <script type="text/javascript">
    Reveal.on('ready', event => {
      if (event.indexh === 0) {
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
    });
    Reveal.addEventListener('slidechanged', (event) => {
      if (event.indexh === 0) {
        Reveal.configure({ slideNumber: null });
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
      if (event.indexh === 1) {
        Reveal.configure({ slideNumber: 'c' });
        document.querySelector("div.has-logo > img.slide-logo").style.display = null;
      }
    });
  </script>
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, include = TRUE, warning = FALSE, message = FALSE,
  fig.align = "center"
)
library(palmerpenguins)
library(dplyr)
```

## Motivation

- We've seen a bunch of ways to explore our data
- Only using one function at a time

. . .

- Perhaps we might like to subset (i.e. filter) our data, then sort it
- How do we do that?


::: {.notes}
- Should we stick with DataExploration.R?
:::

## The Ugly (Old-School) Way

- Let's say we only want information on the Adelie penguins
- Then we want to sort this by body_mass

```{r}
#| output: false
## First we can subset the dataset
filter(penguins, species == "Adelie")
```

. . .

How do we then pass this to the `arrange()` function?

. . . 

1. We could save this as a new object and then call `arrange()` on that object
2. We could place the output of `filter()` inside `arrange()`

## The Ugly (Old-School) Way


```{r}
#| output: false
# Let's create an object first: 'adelie_penguins'
adelie_penguins <- filter(penguins, species == "Adelie")

# Now we can pass this to `arrange()`
arrange(adelie_penguins, body_mass_g)
```

. . .

::: {.callout-note collapse="true"}
## Is this any good?

A complete analysis would lead to a workspace with multiple, similar objects, e.g.
`adelie_penguins`, `penguins_2007`, `torgerson_penguins`, etc.

This can become very messy and confusing
:::


## Another Ugly (Old-School) Way

```{r}
#| output: false
# This time, we can wrap the output of one function inside the other
arrange(
  filter(penguins, species == "Adelie"), 
  body_mass_g
)
```

. . .

- We have first filtered our dataset $\implies$ becomes the `tibble` to be sorted

::: {.callout-note collapse="true"}
## Is this any good?

Functions are executed in order from the inside-most function to the outer-most. First the filtering is done, and then this is passed to `arrange()`

Can become very messy if calling 10 functions in a row
:::

## The Pipe Operator

- R v.4.1 introduced the (base) *pipe operator*: `|>`
- Exactly like sticking a pipe or a hose on the output of one function then placing the pipe as the input of the next 

. . .

- This allows us to pass the output of one function to the next
    + Can chain together multiple functions
    + No need to create intermediate objects
    + No need to wrap the output of one function inside another
    
. . . 

- The output of the first function is passed to the next
    + By default, it will be the *first* argument
    
## The Pipe Operator

```{r}
#| output-location: fragment
# This is conventionally how we've used filter
filter(penguins, species == "Adelie") 
```

## The Pipe Operator

```{r}
#| output-location: fragment
# Here, we're passing the object to filter using |>
penguins |> filter(species == "Adelie")
```

::: {.fragment}
- Calling an object by name simply returns the complete object
:::

## The Pipe Operator

```{r}
# Filter the object, then pass the filtered object to arrange using the pipe
penguins |> filter(species == "Adelie") |> arrange(body_mass_g)
```

## Forming a Chain Across Multiple Lines

- A common practice is to spread these chains across multiple lines
- We can comment anywhere we please

```{r}
#| output: false
penguins |> 
  filter(species == "Adelie") |> # First filter the species
  arrange(body_mass_g) # Now sort by body mass
```

. . .

- Makes long chains much easier to read
- Can easily comment out a line when building/testing code


## A Longer Example

- Let's find the heaviest 5 Adelie penguins

```{r}
#| output: false
penguins |> 
  filter(species == "Adelie") |> # First filter the species
  arrange(desc(body_mass_g)) |> # Now sort by body mass, descending
  slice_head(n = 5) # Take the first 5 rows
```

## Some Challenges To Solve

1. Find the lightest 5 Gentoo penguins
    + Return the weights in `kg` instead of `g`
2. Find the mean bill length for male penguins
    + Sort your answer in descending order
3. Find how many penguins were measured per year on each island
    + Sort your answer by island, then by year
    
# Manipulating Tibbles with <br>`tidyr` {background-color="#3d3d40" background-image=https://tidyr.tidyverse.org/logo.png background-size="30%" background-opacity="0.4" background-position='70% 50%'}

## The Package `tidyr`

### TODO
- Pivoting tables longer/wider
- Unite & separate columns
- Maybe use complete
