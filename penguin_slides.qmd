---
title: "Exploring Data In R"
subtitle: "RAdelaide 2025"
author: "Dr Stevie Pederson"
institute: |
  | Black Ochre Data Labs
  | Telethon Kids Institute
date: "2025-07-08"
date-format: long
bibliography: bibliography.bib
title-slide-attributes:
    data-background-color: "#3d3d40"
    data-background-image: assets/bodl_logo_white_background.jpg
    data-background-opacity: "0.3"
    data-background-size: "90%"
editor: source
format: 
  revealjs:
    theme: [bodl.scss]
    code-line-numbers: false
    code-tools: true
    logo: assets/bodl_logo_white_background.jpg
    height: 720
    width: 1280
    sansfont: Times New Roman
    slide-number: c
    show-slide-number: all
  html: 
    css: [bodl.scss, extra.css]
    output-file: penguins.html
    embed-resources: true    
    toc: true
    toc-depth: 1    
include-after: |
  <script type="text/javascript">
    Reveal.on('ready', event => {
      if (event.indexh === 0) {
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
    });
    Reveal.addEventListener('slidechanged', (event) => {
      if (event.indexh === 0) {
        Reveal.configure({ slideNumber: null });
        document.querySelector("div.has-logo > img.slide-logo").style.display = "none";
      }
      if (event.indexh === 1) { 
        Reveal.configure({ slideNumber: 'c' });
        document.querySelector("div.has-logo > img.slide-logo").style.display = null;
      }
    });
  </script>    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, include = TRUE, warning = FALSE, message = FALSE, 
  fig.align = "center"
)
```


## Introducing The Penguins

- Let's look at a common data structure in `R`
- A data type know as a `tibble`
    + Will explore structure later in the course
    + A `tibble` is a specific type of data frame

. . .

- We'll be looking at the "Palmer Penguins" dataset
    + Taken from https://allisonhorst.github.io/palmerpenguins/index.html
    + 3 species of penguins from the Palmer Archipelago, Antarctica

![](https://allisonhorst.github.io/palmerpenguins/logo.png){.absolute bottom=320 right=120 width='250px'}

## Exploring The Penguins

- We won't be creating any objects in this section
- Learning how to explore a dataset using `dplyr`
    + For organising data 
    + For creating summary tables
    + To prepare for creating plots & figures

. . .

- We'll cover a huge amount of ground
    + Hopefully the exercises & challenges help



## Starting An R Script

- Best practice is to ALWAYS record your code
- Today we'll use an R script
    + Is a plain text file
    + Is a combination of code and comments
    + The filename should end with `.R`
    
. . .
    
- Nothing we enter in the script is executed <br>$\implies$ **until we intentionally execute the code**

## Starting An R Script

- At the top of your file `DataExploration.R` type the following

```{r}
# Load the palmerpenguins package
library(palmerpenguins)
```

. . .

- The `#` symbol indicates a comment
    + Comments are ignored by R and nothing is executed
    + They are used to explain code to humans
    
. . .

- We write code for two primary reasons
    1. To be executed by R, and
    2. To be read  and understood by humans (usually us in a few months)

## Executing Code

- So far, no code has been executed from this script
- Check your **Environment** Tab to see if there are any objects
    + If there is an object (most likely `x`) $\implies$ click the broom icon 
    + This will clear any existing objects from the environment
    

![](assets/broom.png){.absolute width='50px' right=200 bottom=450}

. . .

*How do we execute code from our script?*

## Executing Code

- We can execute code in a few ways

1. Place the cursor on the line of code `library(palmerpenguins)` 
2. Use the keyboard shortcut `Ctrl + Enter` (Windows/Linux) or `Cmd + Enter` (Mac)

. . .

3. Alternatively, you can click the `Run` button in the top right of the script editor

## What have we done so far?

- We have simply loaded the `palmerpenguins` package
    + We called the function `library()`
    + This loads all the functions and the data in a requested package
    + The package name appears **inside** the parentheses `()`
    + Very similar to calling `sqrt(5)` as we saw earlier
    
. . .    

- For python users is equivalent to `import palmerpenguins`

## The `penguins` dataset

::: {style="font-size: 95%;"}

- The `palmerpenguins` package contains a dataset called `penguins`
    + Add the comment and code below, then execute
    + Typing an object's name will 'print' it into the console

```{r}
#| output-location: fragment
# Let's look at the penguins dataset
penguins
```

:::

::: {.notes}
- Maybe get people to click on the Global Environment Tab  
:::


## The `penguins` dataset

- The `penguins` dataset is a `tibble`
- The number of rows and columns is shown at the top (`344 x 8`)
    + Printed as a comment
    
. . .
    
- Next is the column names:
    + `r pander::pander(colnames(penguins))`
    + The last two columns may just be listed at the bottom
    + Is a function of screen width, font size etc
    
::: {.notes}
- Check to see if all columns have printed for everyone
:::    


## The `penguins` dataset

- Underneath each column name is the *data type*
    + Will explore data types in more detail
    + Each column has the same type of data
    + `<fct>` means 'factor' $\implies$ a categorical variable
    + `<dbl>` means 'double' $\implies$ a numeric variable
    + `<int>` means 'integer' $\implies$ a whole number
    
. . .

- Final lines show how many more rows & columns there are
- Notice there are no rownames, just row numbers

## An Alternative Way to View Penguins

```{r}
#| output: false
#| eval: false
# We can also use the View() function
View(penguins)
```

. . .

- I personally prefer seeing things printed in the console
    + Summarises the data
    + Describes the column types
- Leaving `View()` in a simple script is OK for exploration
    + Unhelpful when running long scripts

## Exploring Penguins

- A common initial data exploration task is to get a summary of the data

```{r}
# The column names are:
colnames(penguins)
```

Copy the column names after the code, then comment

::: {.columns}

::: {.column width="55%"}

1. Highlight the output in the console
2. Copy & paste into the script
3. Make a comment by adding `#` at the start of each line

:::

::: {.column width="45%"}

::: {.fragment}

::: {.callout-tip collapse="true"}

## Commenting Multiple Lines

- Comments can be toggled on/off across multiple lines using:
    + `Ctrl + Shift + C` (Win/Linux)
    + `Cmd + Shift + C` (Mac)
    
:::

:::

:::

:::

## Calling Functions

- Notice that we placed the object inside the parentheses `()` after the function

. . . 

- Let's continue checking the object

```{r}
#| output: false
# Find out how big the dataset is
nrow(penguins)
ncol(penguins)
dim(penguins)
```

. . .

- Can you figure out what each of these functions does?
- The same summary information printed when we called the object by name

## Calling Functions

- Let's look at the top and bottom of the dataset

```{r}
#| output: false
# What does the top of the dataset look like?
head(penguins)

# What does the bottom of the dataset look like?
tail(penguins)
```

. . .

- These functions print 6 rows by default
- We can change this $\implies$ let's check the help page
    + In the console type `?head` (We don't need a record of this)
    
##

::: {style="font-size: 85%;"}

### Return the First or Last Parts of an Object

**Description**

Returns the first or last parts of a vector, matrix, array, table, data frame or function. 
Since `head()` and `tail()` are generic functions, they have been extended to other classes, including "ts" from stats.

**Usage**
```
head(x, ...)
## Default S3 method:
head(x, n = 6L, ...)
## S3 method for class 'matrix'
head(x, n = 6L, ...) # is exported as head.matrix()
## NB: The methods for 'data.frame' and 'array'  are identical to the 'matrix' one

blah blah blah ...
```

**Arguments**

`x` an object

`n` an integer vector of length up to dim(x) (or 1, for non-dimensioned objects). Blah blah blah

:::

## Function Arguments

- This is telling as that the function `head()` ( and also `tail()`) can take two arguments
- The first is an object `x`
    + We often call argument that can be anything `x`
- The second is an argument named `n`
    + That `n` is followed by `= 6L` tells us `n` has a default value
    + This is why 6 rows were always printed
    
::: {.notes}
- The `L` after 6 is shorthand to force the value to be an integer
:::

## Function Arguments

    
```{r}
#| output: false
# Print the first 10 rows by setting n = 10
head(penguins, n = 10)

# Repeat for the bottom 10 rows
tail(penguins, n = 10)
```

. . .

<br>

```{r}
#| output: false
# Arguments can be named explicitly
head(x = penguins, n = 10)

# If passed in order, we don't need to name them
head(penguins, 10)

# If naming explicitly, the order doesn't matter
# This is very useful when there are multiple arguments
head(n = 10, x = penguins)
```

::: {.notes}
- This is a relatively trivial function $\implies$ we'll be much more interesting soon
- Also link to `?extraChIPs::plotSplitDonut`
:::

# The package<br>`dplyr` {background-color="#3d3d40" background-image=https://dplyr.tidyverse.org/logo.png background-size="30%" background-opacity="0.4" background-position='70% 50%'}

## Exploring Penguins with `dplyr`

- The `dplyr` package provides multiple functions for data exploration and manipulation
- Let's load the package
    + I personally load all packages at the start of a script
    + Add this underneath the `library(palmerpenguins)` line

```{r}
library(dplyr) # Load the package `dplyr`
```

. . .

- We'll use these functions to explore the `penguins` dataset
- Then we can modify the dataset

::: {.notes}
- `dplyr` was written initially by Hadley Wickham
- He's originally from NZ so he knows how to spell things correctly
:::

## Exploring Penguins with `dplyr`

```{r}
## The `glimpse()` function is provided by dplyr
## Can be very helpful with large column numbers
glimpse(penguins)
```

. . .

- So far we haven't actually saved any objects (using `<-`)
- Functions `head()`, `tail()`, and `glimpse()` are all printing to the console

## Sorting Penguins

- `dplyr` provides some Excel-like functions:
    + `arrange()` will sort the data
    + `filter()` will filter the data
    
```{r}
#| output: false
# Sort the penguins by body mass in increasing order
arrange(penguins, body_mass_g)

# Sort the penguins by body mass in decreasing order
arrange(penguins, desc(body_mass_g))
```

. . .

<br>

```{r}
#| output: false
# Sort multiple columns in the order passed to the function
arrange(penguins, species, body_mass_g)
```

## Filtering Penguins

Filtering relies on *logical tests*

. . .

| Symbol | Description |
|:------ |:----------- |
| `==`   | Is Equal To |
| `>` / `<` | Is Greater/Less Than |
| `>=` / `<=` | Is Greater/Less Than or Equal To |
| `!=`  | Is Not Equal To |
| `is.na()` | Is Missing Value |

## Filtering Penguins

```{r}
#| output: false
## Subset the data to those from the Island of Dream
filter(penguins, island == "Dream")

## Subset the data to those NOT from the Island of Dream
filter(penguins, island != "Dream")

## Subset the penguins to those lighter than 4000g
filter(penguins, body_mass_g < 4000)

## Find the penguins from Dream that are heavier than 4000g
filter(penguins, island == "Dream", body_mass_g > 4000)
```


## Slicing Penguins

- `filter()` returns the rows that *match a given criteria*
- `slice()` can be used to return rows *by position*

```{r}
#| output: false
## Slice out the first 10 rows of the penguins dataset
slice(penguins, 1:10)

## Now slice out the 101st to 110th rows
slice(penguins, 101:110)
```

## A Brief Diversion

- In the two previous examples we used a sequence of consecutive values

```{r}
1:10
101:110
```

. . .

<br>

- We refer to one or more values in `R` as a **vector**
    + These are *integer* vectors

## A Brief Diversion

- In `R` we can form a vector by combining values with the function `c()`

```{r}
c(1, 3, 5, 7, 9)
```

. . .

<br>

```{r}
#| output: false
# Return the first few odd numbered rows using a vector of positions
slice(penguins, c(1, 3, 5, 7, 9))
```

. . .

<br>

```{r}
#| output: false
# Rows can be returned in any order
slice(penguins, c(3, 7, 5, 1))
```

## Selecting Penguins

- `filter()` and `slice()` can be used to return rows
- `select()` can be used to return columns

```{r}
#| output: false
# Columns can be 'selected' by passing the required column names
select(penguins, species, island, body_mass_g)
```

. . . 

<br>

```{r}
#| output: false
# Columns can also be selected by position using a vector
select(penguins, c(1, 2, 6))
```


. . .

::: {.callout-note collapse="true"}
## Using Names Or Position

1. Do the above lines give the same result?
2. Would either one be preferable?
:::

## Helper Functions

- `dplyr` provides some helper functions to make selecting columns easier
- `starts_with()`, `ends_with()` and `contains()`, are very useful!
- `everything()` is also surprisingly useful
- `any_of()` and `all_of()` are a bit more advanced

. . .

```{r}
#| output: false
# Select all columns that start with "bill", after the species and island columns
select(penguins, species, island, starts_with("bill"))

# Select all length-related columns, after the species and island columns
select(penguins, species, island, contains("length"))
```

## Helper Functions 


```{r}
#| output: false
# Place all metadata first, followed by measured values
# This line shows how useful 'everything()' can be
select(penguins, species, island, sex, year, everything())
```

. . .

- To remove a column, we preface the selection with `-`

```{r}
#| output: false
# Remove all columns that end with 'mm'
select(penguins, -ends_with("mm"))
```


## Relocate

```{r}
#| output: false
# Relocate is a newer addition to dplyr and can also be used to reorder columns
# The arguments .before and .after can be used to specify where to place columns
# Here we're moving columns with an underscore to after the year column
relocate(penguins, contains("_"), .after = year)

# This time, we're moving the sex and year columns to 'before' the bill columns
relocate(penguins, sex, year, .before = starts_with("bill"))
```

## Modifying Columns With `mutate()`

- So far, we've only subset our data using various methods
- `mutate()` is used to modify existing columns or create new ones

```{r}
#| output: false
# Create a column called `body_mass_kg` that is the body mass in kg
mutate(penguins, body_mass_kg = body_mass_g / 1000)
```


## Exercises

::: {style="font-size: 90%;"}

1. Use `filter()` to find all female penguins
2. Use `filter()` to find all female penguins with a flipper length greater than 215mm
3. Use `filter()` to find all penguins where `sex` is missing (`NA`)
4. Sort the dataset by bill_length in descending order
5. Use `select()` to return the species, island, and year columns
6. Repeat the above trying an alternative approach to your first answer
7. Place the `year` column after `island` and remove the `sex` column
8. Create the column `bill_ratio` by dividing `bill_length_mm` by `bill_depth_mm`

:::

# Summarising The Dataset {background-color="#3d3d40"}

## Obtaining Summaries

- `dplyr` also provides functions to summarise data
    + `count()` and `summarise()` are the most common
    + We can tell these functions which columns to summarise by
    
```{r}
#| output: false
# Count the number of penguins by species
count(penguins, species)

# Count the number of penguins by species and island
count(penguins, species, island)

# If we change the order of the columns, we get a different order
count(penguins, island, species)

# The argument `sort = TRUE` will sort the results
count(penguins, species, island, sort = TRUE)
```

## Obtaining Summaries

- More nuanced summaries can be obtained using `summarise()`
    + We now pass the grouping variable to the argument `.by`
    + The summary column should also be given a name


```{r}
#| output: false
# Find the mean weight of each species
summarise(penguins, mean_weight = mean(body_mass_g), .by = species)
```

. . .

- This is the first time those missing values have caused us grief
    + The argument `na.rm = TRUE` will tell `mean()` to ignore `NA` values
    
```{r}
#| output: false
# Ignore the missing values when calculating the mean
summarise(penguins, mean_weight = mean(body_mass_g, na.rm = TRUE), .by = species)
```

## Obtaining Summaries

- We can also summarise using multiple columns

```{r}
#| output: false
# Summarise by both species and year
summarise(
  penguins, mean_weight = mean(body_mass_g, na.rm = TRUE), .by = c(species, year)
)
```

::: {.callout-note collapse="true"}
- The code is split across multiple lines just to fit on the slide
:::

## Obtaining Summaries

- We could split across multiple lines for greater readability

```{r}
#| output: false
# Summarise by both species and year
summarise(
  penguins, 
  mean_weight = mean(body_mass_g, na.rm = TRUE), 
  .by = c(species, year)
)
```

## Obtaining Summaries

- This strategy can help when creating multiple summary columns
- Instead of using `count()` we can call `n()` as part of `summarise()`

```{r}
#| output: false
# Summarise by both species and year, counting the number of penguins
summarise(
  penguins, 
  mean_weight = mean(body_mass_g, na.rm = TRUE), 
  total = n(),
  .by = c(species, year)
)
```

## Grouping Arguments

- The recent addition of `.by` has beefed up some earlier functions

```{r}
#| output: false
# Grab the first 5 rows of each species
slice(penguins, 1:5, .by = species)
```

. . .

- Some newer extensions of `slice()` are also useful for summarising data
    + `slice_min()`, `slice_max()`
- Confusingly, `.by` has become `by` here
    + The argument `n = 1` says return only one penguin per species
    
```{r}
#| output: false
# Return the heaviest penguin from each species
slice_max(penguins, body_mass_g, n = 1, by = species)
```

## Conclusion

- All functions so far have enabled exploration
- Have never over-written our original dataset
- Have never created a new object
- Real world applications:
    + Preparing for plotting or regression
    + Summarising data for tables

. . .

- Already a huge amount to remember!
- We'll be doing more exercises soon

